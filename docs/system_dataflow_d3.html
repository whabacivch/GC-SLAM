<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Child SLAM v2 - System Dataflow</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=IBM+Plex+Sans:wght@400;500;600&display=swap');
        
        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            padding: 0;
            background: #080a0e;
            color: #e6edf3;
            font-family: 'IBM Plex Sans', sans-serif;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .header {
            padding: 12px 24px;
            background: #0d1117;
            border-bottom: 1px solid #21262d;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .header h1 {
            margin: 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 15px;
            font-weight: 600;
            color: #58a6ff;
        }
        
        .header-info {
            display: flex;
            gap: 20px;
            font-size: 10px;
            color: #6e7681;
            font-family: 'JetBrains Mono', monospace;
        }
        
        #diagram-container {
            width: 100%;
            height: calc(100vh - 44px);
        }
        
        .cluster-label {
            font-family: 'IBM Plex Sans', sans-serif;
            font-weight: 600;
            font-size: 9px;
            letter-spacing: 0.6px;
            text-transform: uppercase;
        }
        
        .node-rect { rx: 4; ry: 4; }
        .node:hover .node-rect { filter: brightness(1.2); cursor: default; }
        
        .node-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            fill: #e6edf3;
            pointer-events: none;
        }
        
        .node-sublabel {
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 6.5px;
            fill: #8b949e;
            pointer-events: none;
        }
        
        .edge { fill: none; }
        
        .controls {
            position: fixed;
            bottom: 12px;
            right: 12px;
            display: flex;
            gap: 4px;
            z-index: 100;
        }
        
        .controls button {
            width: 28px;
            height: 28px;
            border: 1px solid #30363d;
            background: #0d1117;
            color: #e6edf3;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .controls button:hover {
            background: #21262d;
            border-color: #58a6ff;
        }
        
        .legend {
            position: fixed;
            bottom: 12px;
            left: 12px;
            background: #0d1117;
            border: 1px solid #21262d;
            border-radius: 6px;
            padding: 10px 12px;
            z-index: 100;
        }
        
        .legend-title {
            font-size: 7px;
            color: #6e7681;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            font-weight: 600;
        }
        
        .legend-items {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 8px;
            font-family: 'JetBrains Mono', monospace;
            color: #8b949e;
        }
        
        .legend-box {
            width: 12px;
            height: 8px;
            border-radius: 2px;
            border-width: 1.5px;
            border-style: solid;
        }
    
        .legend-item.clickable { cursor: pointer; user-select: none; }
        .legend-item.clickable:hover { color: #e6edf3; }
        .legend-item.off { opacity: 0.35; }
        .legend-line {
            width: 14px;
            height: 0;
            border-top-width: 2px;
            border-top-style: solid;
            border-radius: 2px;
        }

</style>
</head>
<body>
    <div class="header">
        <h1>Golden Child SLAM v2 — System Dataflow</h1>
        <div class="header-info">
            <span>15 Pipeline Steps</span>
            <span>4 Hypotheses</span>
            <span>M3DGR Dynamic01</span>
        </div>
    </div>
    
    <div id="diagram-container"></div>
    
    
    <div class="legend">
        <div class="legend-title">Node Types</div>
        <div class="legend-items">
            <div class="legend-item"><div class="legend-box" style="background: rgba(63,185,80,0.15); border-color: #3fb950;"></div>Active</div>
            <div class="legend-item"><div class="legend-box" style="background: rgba(88,166,255,0.15); border-color: #58a6ff;"></div>Evidence</div>
            <div class="legend-item"><div class="legend-box" style="background: rgba(210,153,34,0.15); border-color: #d29922;"></div>Approx</div>
            <div class="legend-item"><div class="legend-box" style="background: rgba(163,113,247,0.15); border-color: #a371f7;"></div>Hypothesis</div>
            <div class="legend-item"><div class="legend-box" style="background: rgba(110,118,129,0.12); border-color: #6e7681;"></div>State</div>
            <div class="legend-item"><div class="legend-box" style="background: rgba(248,81,73,0.12); border-color: #f85149; border-style: dashed;"></div>Dead-end</div>
        </div>

        <div class="legend-title" style="margin-top:10px;">Edge Types</div>
        <div class="legend-items" id="edge-legend">
            <div class="legend-item clickable edge-legend-item" data-edge-type="data"><div class="legend-line" style="border-top-color:#3fb950;"></div>Data</div>
            <div class="legend-item clickable edge-legend-item" data-edge-type="flow"><div class="legend-line" style="border-top-color:#3fb950;"></div>Flow</div>
            <div class="legend-item clickable edge-legend-item" data-edge-type="buffer"><div class="legend-line" style="border-top-color:#3fb950; border-top-style:dashed;"></div>Buffer</div>
            <div class="legend-item clickable edge-legend-item" data-edge-type="evidence"><div class="legend-line" style="border-top-color:#58a6ff;"></div>Evidence</div>
            <div class="legend-item clickable edge-legend-item" data-edge-type="hypo"><div class="legend-line" style="border-top-color:#a371f7;"></div>Hypo</div>
            <div class="legend-item clickable edge-legend-item" data-edge-type="feedback"><div class="legend-line" style="border-top-color:#6e7681; border-top-style:dashed;"></div>Feedback</div>
            <div class="legend-item clickable edge-legend-item" data-edge-type="iw"><div class="legend-line" style="border-top-color:#d29922; border-top-style:dashed;"></div>IW</div>
            <div class="legend-item clickable edge-legend-item" data-edge-type="output"><div class="legend-line" style="border-top-color:#58a6ff;"></div>Output</div>
            <div class="legend-item clickable edge-legend-item" data-edge-type="dead"><div class="legend-line" style="border-top-color:#f85149; border-top-style:dashed;"></div>Dead</div>
            <div class="legend-item clickable edge-legend-item" data-edge-type="audit"><div class="legend-line" style="border-top-color:#8856a7;"></div>Audit</div>
        </div>
        <div class="legend-title" style="margin-top:8px; font-weight:500;">
            Click to toggle • Shift+click to solo
        </div>
    </div>

    <div class="controls">
        <button onclick="zoomIn()">+</button>
        <button onclick="zoomOut()">−</button>
        <button onclick="resetZoom()">⌘</button>
    </div>

    <script>
        const width = 1800;
        const height = 1400;
        
        const svg = d3.select("#diagram-container")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", `0 0 ${width} ${height}`)
            .attr("preserveAspectRatio", "xMidYMid meet");

        const defs = svg.append("defs");
        
        // Arrow markers
        const markers = {
            green: '#3fb950', blue: '#58a6ff', purple: '#a371f7',
            orange: '#d29922', gray: '#6e7681', red: '#f85149'
        };
        
        Object.entries(markers).forEach(([name, color]) => {
            defs.append("marker")
                .attr("id", `arr-${name}`)
                .attr("viewBox", "0 -4 8 8")
                .attr("refX", 7)
                .attr("refY", 0)
                .attr("markerWidth", 5)
                .attr("markerHeight", 5)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-3L8,0L0,3")
                .attr("fill", color);
        });

        const g = svg.append("g");
        const zoom = d3.zoom()
            .scaleExtent([0.3, 3])
            .on("zoom", e => g.attr("transform", e.transform));
        svg.call(zoom);
        svg.call(zoom.transform, d3.zoomIdentity.translate(30, 20).scale(0.7));

        window.zoomIn = () => svg.transition().duration(200).call(zoom.scaleBy, 1.3);
        window.zoomOut = () => svg.transition().duration(200).call(zoom.scaleBy, 0.7);
        window.resetZoom = () => svg.transition().duration(200).call(zoom.transform, d3.zoomIdentity.translate(30, 20).scale(0.7));

        // ============================================================
        // NODE DATA - With user's custom positions
        // ============================================================
        const nodes = [
            // === ODOM LANE ===
            { id: "BAG_ODOM", label: "/odom", sub: "20 Hz", x: 81, y: 35, w: 130, h: 45, type: "active" },
            { id: "ODOM_NORM", label: "odom_normalizer", sub: "→ base_footprint", x: 80, y: 110, w: 130, h: 55, type: "active" },
            { id: "CAN_ODOM", label: "/gc/sensors/odom", sub: "Odometry", x: 80, y: 190, w: 130, h: 45, type: "active" },
            { id: "S09A", label: "S09a: OdomQuadratic", sub: "Gaussian SE(3)", x: 104, y: 573, w: 170, h: 55, type: "evidence" },
            
            // === LIDAR LANE ===
            { id: "BAG_LIDAR", label: "/livox/mid360/lidar", sub: "10 Hz", x: 300, y: 40, w: 170, h: 45, type: "active" },
            { id: "LIVOX_CONV", label: "livox_converter", sub: "→ PointCloud2", x: 300, y: 110, w: 170, h: 55, type: "active" },
            { id: "CAN_LIDAR", label: "/gc/sensors/lidar_points", sub: "PointCloud2", x: 300, y: 190, w: 170, h: 45, type: "active" },
            
            // Preprocessing
            { id: "S01", label: "S01: PointBudget", sub: "8192 pts", x: 251, y: 280, w: 150, h: 55, type: "exact" },
            { id: "S02", label: "S02: PredictDiffusion", sub: "Q, dt", x: 462, y: 282, w: 150, h: 55, type: "exact" },
            { id: "S03", label: "S03: Deskew", sub: "IMU preint", x: 652, y: 283, w: 150, h: 55, type: "approx" },
            
            // Binning (snake pattern)
            { id: "S04", label: "S04: BinSoftAssign", sub: "48 bins", x: 641, y: 366, w: 150, h: 55, type: "exact" },
            { id: "S05", label: "S05: MomentMatch", sub: "map_stats", x: 430, y: 370, w: 150, h: 55, type: "exact" },
            { id: "S06", label: "S06: Kappa", sub: "κ_map, κ_scan", x: 213, y: 373, w: 150, h: 55, type: "exact" },
            { id: "S07", label: "S07: MatrixFisherRotation", sub: "Rotation R̂", x: 213, y: 464, w: 150, h: 55, type: "exact" },
            { id: "S08", label: "S08: PlanarTranslation", sub: "Translation t̂", x: 643, y: 460, w: 150, h: 55, type: "exact" },
            
            // Evidence
            { id: "S09D", label: "S09d: LidarEvidence", sub: "MF + planar", x: 752, y: 584, w: 170, h: 55, type: "evidence" },
            
            // === IMU LANE ===
            { id: "BAG_IMU", label: "/livox/mid360/imu", sub: "200 Hz", x: 550, y: 40, w: 150, h: 45, type: "active" },
            { id: "IMU_NORM", label: "imu_normalizer", sub: "→ livox_frame", x: 550, y: 110, w: 150, h: 55, type: "active" },
            { id: "CAN_IMU", label: "/gc/sensors/imu", sub: "Imu", x: 550, y: 190, w: 150, h: 45, type: "active" },
            { id: "IMU_BUF", label: "IMU Buffer", sub: "4000 msgs", x: 847, y: 177, w: 130, h: 65, type: "buffer" },
            
            // Evidence from IMU
            { id: "S09B", label: "S09b: ImuVMFGravityTimeResolved", sub: "vMF S²", x: 332, y: 577, w: 170, h: 55, type: "approx" },
            { id: "S09C", label: "S09c: ImuGyroRot", sub: "Gaussian SO(3)", x: 547, y: 576, w: 170, h: 55, type: "evidence" },
            
            // === FUSION (reverse direction) ===
            { id: "S10", label: "S10: FusionScale", sub: "Excitation", x: 801, y: 692, w: 150, h: 55, type: "approx" },
            { id: "S11", label: "S11: InfoFusion", sub: "L = L_prior + L_ev", x: 361, y: 692, w: 150, h: 55, type: "exact" },
            { id: "S12", label: "S12: PoseUpdate", sub: "Frobenius", x: 131, y: 693, w: 150, h: 55, type: "approx" },
            { id: "S13", label: "S13: CovInflation", sub: "Map update", x: 138, y: 795, w: 150, h: 55, type: "exact" },
            { id: "S14", label: "S14: AnchorDrift", sub: "Anchor maint", x: 387, y: 791, w: 150, h: 55, type: "exact" },
            
            // === HYPOTHESIS ===
            { id: "S15", label: "S15: HypothesisBarycenter", sub: "4 Hyp → 1 Belief", x: 765, y: 791, w: 200, h: 55, type: "hypothesis" },
            
            // === STATE STORAGE ===
            { id: "ST_BELIEF", label: "BeliefGaussianInfo", sub: "22D × 4 Hyp", x: 804, y: 981, w: 170, h: 60, type: "state" },
            { id: "ST_MAP", label: "MapBinStats", sub: "48 bins", x: 638, y: 992, w: 150, h: 60, type: "state" },
            { id: "ST_PROC", label: "ProcessNoiseIW", sub: "Q 22×22", x: 116, y: 981, w: 150, h: 60, type: "state_dim" },
            { id: "ST_MEAS", label: "MeasNoiseIW", sub: "Σg, Σa", x: 306, y: 976, w: 150, h: 60, type: "state_dim" },
            { id: "ST_BUCKET", label: "BucketNoiseIW", sub: "Per-bin λ", x: 469, y: 982, w: 150, h: 60, type: "state_dim" },
            
            // === OUTPUTS ===
            { id: "OUT_STATE", label: "/gc/state", sub: "Odometry", x: 403, y: 1121, w: 140, h: 45, type: "output" },
            { id: "OUT_TRAJ", label: "/gc/trajectory", sub: "Path", x: 714, y: 1117, w: 140, h: 45, type: "output" },
            { id: "OUT_STATUS", label: "/gc/status", sub: "JSON", x: 1186, y: 1129, w: 140, h: 45, type: "output" },
            { id: "OUT_MANIFEST", label: "/gc/runtime_manifest", sub: "JSON", x: 1347, y: 1133, w: 140, h: 45, type: "output" },
            { id: "OUT_CERT", label: "/gc/certificate", sub: "CertBundle", x: 554, y: 1119, w: 140, h: 45, type: "output" },
            { id: "OUT_TUM", label: "Trajectory.txt", sub: "TUM", x: 868, y: 1120, w: 140, h: 45, type: "output" },
            { id: "OUT_NPZ", label: "Diagnostics.npz", sub: "Metrics", x: 1019, y: 1122, w: 140, h: 45, type: "output" },
            { id: "OUT_TF", label: "TF Broadcast", sub: "odom→base", x: 826, y: 1219, w: 140, h: 45, type: "tf" },
            
            // === DEAD-END ===
            { id: "BAG_VRPN", label: "/vrpn.../UGV/pose", sub: "Ground Truth", x: 768, y: 42, w: 150, h: 45, type: "dead" },
            { id: "BAG_CAM_IMU", label: "/camera/imu", x: 1102, y: 51, w: 120, h: 45, type: "dead" },
            { id: "BAG_CAM_COLOR", label: "/camera/color", sub: "compressed", x: 935, y: 47, w: 150, h: 45, type: "dead" },
            { id: "BAG_CAM_DEPTH", label: "/camera/depth", sub: "compressedDepth", x: 1240, y: 48, w: 150, h: 45, type: "dead" },
            { id: "BAG_AVIA_LIDAR", label: "/livox/avia/lidar", x: 1558, y: 44, w: 130, h: 45, type: "dead" },
            { id: "BAG_AVIA_IMU", label: "/livox/avia/imu", x: 1408, y: 48, w: 130, h: 45, type: "dead" },
            
            { id: "DEAD_AUDIT", label: "dead_end_audit", sub: "Tracks unused", x: 1206, y: 242, w: 150, h: 55, type: "audit" },
            { id: "CAN_DEAD", label: "/gc/dead_end_status", sub: "JSON", x: 1207, y: 354, w: 150, h: 45, type: "audit" }
        ];

        // Node styles
        const styles = {
            active: { fill: "rgba(63,185,80,0.12)", stroke: "#3fb950" },
            exact: { fill: "rgba(63,185,80,0.12)", stroke: "#3fb950" },
            approx: { fill: "rgba(210,153,34,0.12)", stroke: "#d29922" },
            evidence: { fill: "rgba(88,166,255,0.12)", stroke: "#58a6ff" },
            buffer: { fill: "rgba(63,185,80,0.08)", stroke: "#3fb950" },
            hypothesis: { fill: "rgba(163,113,247,0.15)", stroke: "#a371f7" },
            state: { fill: "rgba(110,118,129,0.12)", stroke: "#6e7681" },
            state_dim: { fill: "rgba(110,118,129,0.08)", stroke: "#484f58" },
            output: { fill: "rgba(88,166,255,0.1)", stroke: "#58a6ff" },
            tf: { fill: "rgba(63,185,80,0.1)", stroke: "#3fb950" },
            dead: { fill: "rgba(248,81,73,0.08)", stroke: "#f85149", dash: "4,2" },
            audit: { fill: "rgba(136,86,167,0.1)", stroke: "#8856a7" }
        };

        const nodeMap = {};
        nodes.forEach(n => nodeMap[n.id] = n);

        // ============================================================
        // EDGES
        // ============================================================
        const edges = [
            // ODOM lane
            { from: "BAG_ODOM", to: "ODOM_NORM", type: "data" },
            { from: "ODOM_NORM", to: "CAN_ODOM", type: "data" },
            { from: "CAN_ODOM", to: "S09A", type: "data" },
            
            // LIDAR lane
            { from: "BAG_LIDAR", to: "LIVOX_CONV", type: "data" },
            { from: "LIVOX_CONV", to: "CAN_LIDAR", type: "data" },
            { from: "CAN_LIDAR", to: "S01", type: "data" },
            
            // Pipeline
            { from: "S01", to: "S02", type: "flow" },
            { from: "S02", to: "S03", type: "flow" },
            { from: "S03", to: "S04", type: "flow" },
            { from: "S04", to: "S05", type: "flow" },
            { from: "S05", to: "S06", type: "flow" },
            { from: "S06", to: "S07", type: "flow" },
            { from: "S07", to: "S08", type: "flow" },
            
            // S08 → Evidence
            { from: "S08", to: "S09A", type: "evidence" },
            { from: "S08", to: "S09B", type: "evidence" },
            { from: "S08", to: "S09C", type: "evidence" },
            { from: "S08", to: "S09D", type: "evidence" },
            
            // IMU lane
            { from: "BAG_IMU", to: "IMU_NORM", type: "data" },
            { from: "IMU_NORM", to: "CAN_IMU", type: "data" },
            { from: "CAN_IMU", to: "IMU_BUF", type: "data" },
            { from: "IMU_BUF", to: "S03", type: "buffer" },
            { from: "IMU_BUF", to: "S09B", type: "buffer" },
            { from: "IMU_BUF", to: "S09C", type: "buffer" },
            
            // Evidence → Fusion
            { from: "S09A", to: "S10", type: "evidence" },
            { from: "S09D", to: "S10", type: "evidence" },
            { from: "S09B", to: "S10", type: "evidence" },
            { from: "S09C", to: "S10", type: "evidence" },
            
            // Fusion chain (now goes right to left, then down)
            { from: "S10", to: "S11", type: "flow" },
            { from: "S11", to: "S12", type: "flow" },
            { from: "S12", to: "S13", type: "flow" },
            { from: "S13", to: "S14", type: "flow" },
            { from: "S14", to: "S15", type: "hypo" },
            
            // Hypothesis → State
            { from: "S15", to: "ST_BELIEF", type: "hypo" },
            { from: "S15", to: "ST_MAP", type: "hypo" },
            
            // Feedback
            { from: "ST_BELIEF", to: "S02", type: "feedback" },
            { from: "ST_PROC", to: "S02", type: "feedback" },
            { from: "ST_MAP", to: "S05", type: "feedback" },
            { from: "ST_BUCKET", to: "S05", type: "feedback" },
            { from: "ST_MEAS", to: "S09B", type: "feedback" },
            { from: "ST_MEAS", to: "S09C", type: "feedback" },
            
            // IW updates
            { from: "S08", to: "ST_BUCKET", type: "iw" },
            { from: "S09B", to: "ST_MEAS", type: "iw" },
            { from: "S09C", to: "ST_MEAS", type: "iw" },
            { from: "S12", to: "ST_PROC", type: "iw" },
            
            // State → Outputs
            { from: "ST_BELIEF", to: "OUT_STATE", type: "output" },
            { from: "ST_BELIEF", to: "OUT_TRAJ", type: "output" },
            { from: "ST_BELIEF", to: "OUT_STATUS", type: "output" },
            { from: "ST_BELIEF", to: "OUT_MANIFEST", type: "output" },
            { from: "ST_BELIEF", to: "OUT_CERT", type: "output" },
            { from: "ST_BELIEF", to: "OUT_TUM", type: "output" },
            { from: "ST_BELIEF", to: "OUT_NPZ", type: "output" },
            { from: "ST_BELIEF", to: "OUT_TF", type: "output" },
            
            // Dead-end
            { from: "BAG_VRPN", to: "DEAD_AUDIT", type: "dead" },
            { from: "BAG_CAM_IMU", to: "DEAD_AUDIT", type: "dead" },
            { from: "BAG_CAM_COLOR", to: "DEAD_AUDIT", type: "dead" },
            { from: "BAG_CAM_DEPTH", to: "DEAD_AUDIT", type: "dead" },
            { from: "BAG_AVIA_LIDAR", to: "DEAD_AUDIT", type: "dead" },
            { from: "BAG_AVIA_IMU", to: "DEAD_AUDIT", type: "dead" },
            { from: "DEAD_AUDIT", to: "CAN_DEAD", type: "audit" },
            { from: "OUT_STATUS", to: "CAN_DEAD", type: "audit" },
            { from: "OUT_MANIFEST", to: "CAN_DEAD", type: "audit" }
        ];

        // Edge styles
        const edgeStyles = {
            data: { color: "#3fb950", width: 2, dash: null, marker: "green" },
            flow: { color: "#3fb950", width: 2, dash: null, marker: "green" },
            buffer: { color: "#3fb950", width: 1.5, dash: "4,2", marker: "green" },
            evidence: { color: "#58a6ff", width: 2, dash: null, marker: "blue" },
            hypo: { color: "#a371f7", width: 2.5, dash: null, marker: "purple" },
            feedback: { color: "#6e7681", width: 1.2, dash: "4,2", marker: "gray" },
            iw: { color: "#d29922", width: 1, dash: "2,2", marker: "orange" },
            output: { color: "#58a6ff", width: 1.5, dash: null, marker: "blue" },
            dead: { color: "#f85149", width: 1, dash: "3,2", marker: "red" },
            audit: { color: "#8856a7", width: 1.5, dash: null, marker: "purple" }
        };

        // ============================================================
        // DRAWING
        // ============================================================
        
        // Edge group first (behind nodes)
        const edgeGroup = g.append("g").attr("class", "edges");
        const nodeGroup = g.append("g").attr("class", "nodes");

        // Get port on node
        function port(n, side) {
            const cx = n.x + n.w/2, cy = n.y + n.h/2;
            switch(side) {
                case 't': return {x: cx, y: n.y};
                case 'b': return {x: cx, y: n.y + n.h};
                case 'l': return {x: n.x, y: cy};
                case 'r': return {x: n.x + n.w, y: cy};
            }
        }

        // Calculate path between nodes
        function calcPath(fromId, toId) {
            const f = nodeMap[fromId], t = nodeMap[toId];
            if (!f || !t) return "";
            
            const dx = (t.x + t.w/2) - (f.x + f.w/2);
            const dy = (t.y + t.h/2) - (f.y + f.h/2);
            
            let fp, tp;
            if (Math.abs(dy) > Math.abs(dx) * 0.5) {
                fp = port(f, dy > 0 ? 'b' : 't');
                tp = port(t, dy > 0 ? 't' : 'b');
            } else {
                fp = port(f, dx > 0 ? 'r' : 'l');
                tp = port(t, dx > 0 ? 'l' : 'r');
            }
            
            const midX = (fp.x + tp.x) / 2;
            const midY = (fp.y + tp.y) / 2;
            
            if (Math.abs(fp.y - tp.y) > Math.abs(fp.x - tp.x) * 0.5) {
                return `M${fp.x},${fp.y} C${fp.x},${midY} ${tp.x},${midY} ${tp.x},${tp.y}`;
            } else {
                return `M${fp.x},${fp.y} C${midX},${fp.y} ${midX},${tp.y} ${tp.x},${tp.y}`;
            }
        }

        // Draw edges (data-joined so we can toggle by type)
        const edgeVisibility = Object.fromEntries(Object.keys(edgeStyles).map(k => [k, true]));

        const edgePaths = edgeGroup.selectAll("path.edge")
            .data(edges)
            .enter()
            .append("path")
            .attr("class", "edge")
            .attr("data-type", d => d.type)
            .attr("d", d => calcPath(d.from, d.to))
            .attr("stroke", d => (edgeStyles[d.type] || edgeStyles.flow).color)
            .attr("stroke-width", d => (edgeStyles[d.type] || edgeStyles.flow).width)
            .attr("stroke-dasharray", d => (edgeStyles[d.type] || edgeStyles.flow).dash)
            .attr("marker-end", d => `url(#arr-${(edgeStyles[d.type] || edgeStyles.flow).marker})`)
            .attr("opacity", 0.7);

        function applyEdgeVisibility() {
            edgePaths.attr("display", d => (edgeVisibility[d.type] ? null : "none"));
            document.querySelectorAll(".edge-legend-item").forEach(el => {
                const t = el.getAttribute("data-edge-type");
                el.classList.toggle("off", !edgeVisibility[t]);
            });
        }

        // Legend click: toggle / solo
        document.querySelectorAll(".edge-legend-item").forEach(el => {
            el.addEventListener("click", (evt) => {
                const t = el.getAttribute("data-edge-type");

                if (evt.shiftKey) {
                    // Solo: show only this type (or reset to all if it was already solo)
                    const currentlySolo = Object.keys(edgeVisibility).every(k => (k === t) === edgeVisibility[k]);
                    if (currentlySolo) {
                        Object.keys(edgeVisibility).forEach(k => edgeVisibility[k] = true);
                    } else {
                        Object.keys(edgeVisibility).forEach(k => edgeVisibility[k] = (k === t));
                    }
                } else {
                    // Toggle
                    edgeVisibility[t] = !edgeVisibility[t];
                }

                applyEdgeVisibility();
            });
        });

        // Initialize legend state
        applyEdgeVisibility();

        // Draw nodes
        nodes.forEach(n => {
            const s = styles[n.type] || styles.active;
            const ng = nodeGroup.append("g").attr("class", "node");
            
            ng.append("rect")
                .attr("class", "node-rect")
                .attr("x", n.x)
                .attr("y", n.y)
                .attr("width", n.w)
                .attr("height", n.h)
                .attr("fill", s.fill)
                .attr("stroke", s.stroke)
                .attr("stroke-width", 1.5)
                .attr("stroke-dasharray", s.dash || null);
            
            ng.append("text")
                .attr("class", "node-label")
                .attr("x", n.x + n.w/2)
                .attr("y", n.y + (n.sub ? 16 : n.h/2 + 3))
                .attr("text-anchor", "middle")
                .attr("font-weight", "600")
                .text(n.label);
            
            if (n.sub) {
                ng.append("text")
                    .attr("class", "node-sublabel")
                    .attr("x", n.x + n.w/2)
                    .attr("y", n.y + 28)
                    .attr("text-anchor", "middle")
                    .text(n.sub);
            }
        });

        // Add section labels
        const labels = [
            { text: "ODOM", x: 145, y: 260, color: "#3fb950" },
            { text: "LIDAR", x: 385, y: 260, color: "#3fb950" },
            { text: "IMU", x: 625, y: 260, color: "#d29922" },
            { text: "PIPELINE", x: 500, y: 540, color: "#3fb950" },
            { text: "EVIDENCE", x: 500, y: 655, color: "#58a6ff" },
            { text: "FUSION", x: 300, y: 870, color: "#3fb950" },
            { text: "STATE", x: 500, y: 1070, color: "#6e7681" },
            { text: "OUTPUTS", x: 850, y: 1200, color: "#58a6ff" },
            { text: "DEAD-END / AUDIT", x: 1280, y: 230, color: "#f85149" }
        ];

        labels.forEach(l => {
            g.append("text")
                .attr("class", "cluster-label")
                .attr("x", l.x)
                .attr("y", l.y)
                .attr("fill", l.color)
                .attr("opacity", 0.6)
                .text(l.text);
        });
    </script>
</body>
</html>
